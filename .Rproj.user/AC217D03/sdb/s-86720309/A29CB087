{
    "collab_server" : "",
    "contents" : "fit=aov(iris$Sepal.Length~iris$Species)\ndescribeBy(iris$Sepal.Length, group = iris$Species)\nfit$residuals\nks.test(fit$residuals,\"pnorm\")\nsummary(fit)\n\nx=matrix(c(1.88,0.42,0.42,0.53), nrow = 2, ncol = 2,byrow = T)\nx\nsolve(x)\nvar(x)\nx=matrix(c(1,2,3,4),ncol = 2)\nsolve(t(x)%*%x)\n\n#Übungsblatt 4\nload(\"/Users/corneliusfritz/Downloads/atemwege.rda\")\natem=cbind(log(atem[,1:3]),atem[,4])\ncov(atem[,2:3])\nmittel=c(mean(atem[,2]),mean(atem[,3]))\nmu=c(log(3),log(1.4))\n(1328*(1328-2))/(2*(1327))*t(mittel-mu)%*% solve(cov(atem[,2:3]))%*% (mittel-mu)\nqf(0.95,df1 = 2,df2 = 1328-2)\n1-pf((1328*(1328-2))/(2*(1327))*t(mittel-mu)%*% solve(cov(atem[,2:3]))%*% (mittel-mu),df1 = 2,df2 = 1328-2)\n\nmittel=c(mean(atem$pef-atem$fef50),mean(atem$pef-atem$fef75))\nmu=c(0,0)\n(1328*(1328-2))/(2*(1327))*t(mittel-mu)%*% solve(cov(cbind(atem$pef-atem$fef50,atem$pef-atem$fef75)))%*% (mittel-mu)\nqf(0.95,df1 = 2,df2 = 1328-2)\n1-pf((1328*(1328-2))/(2*(1327))*t(mittel-mu)%*% solve(cov(atem[,2:3]))%*% (mittel-mu),df1 = 2,df2 = 1328-2)\n\nx1=c(mean(atem[atem[,4]==1,2]),mean(atem[atem[,4]==1,3]))\nx2=c(mean(atem[atem[,4]==2,2]),mean(atem[atem[,4]==2,3]))\nS1=cov(cbind(atem[atem[,4]==1,2],atem[atem[,4]==1,3]))\nS2=cov(cbind(atem[atem[,4]==2,2],atem[atem[,4]==2,3]))\nS=1/(1328-2)*(length(atem[atem[,4]==1,2])*S1+length(atem[atem[,4]==2,2])*S2)\n\n(length(atem[atem[,4]==1,2])*length(atem[atem[,4]==1,1]))/(length(atem[atem[,4]==1,2])+length(atem[atem[,4]==1,1]))*t(x1-x2)%*%solve(S)%*%(x1-x2)\n\nvarmat <- cbind(log.fef50,log.fef75)\nx1.quer <- apply(varmat[atem$sex==1,],2,mean)\nx2.quer <- apply(varmat[atem$sex==2,],2,mean)\n\n#Übungsblatt 6 \n\nairquality\nfit1=lm(airquality$Ozone~airquality$Solar.R+airquality$Wind +airquality$Temp)\nfit2=lm(airquality$Ozone~airquality$Solar.R*airquality$Wind *airquality$Temp)\nsummary(fit1)\nsummary(fit2)\nreg.rpart <- rpart(Ozone~Wind+Temp+Solar.R,data=airquality)\n\n## Schoene Visualisierung \nreg.rpart <- as.party(reg.rpart)\nplot(reg.rpart)\n\nx1=matrix(c(17.683,20.29,20.29,24.407),nrow = 2)\nx2=matrix(c(18.479,19.095,19.095,19.273),nrow = 2)\nx=1/(35+14-2)*(35*x1+14*x2)\nx\ncov(x)\nqchisq(p = 0.95,df = 34)\nsolve(x)\n\n\n# b) \n\nlibrary(MASS)\ndata(geyser)\n\n## kurzer Plot:\nplot(geyser)\n# Man erkennt drei Klassen. Beachte den Rundungseffekt (viele Beob. mit duration = 2 oder 4)\n\n\n# c) \n\n## Package zum Modellbasierten Clustern\nlibrary(mclust)\n\n## Dokumentation:\nhelp(Mclust)\nhelp(mclustModelNames)\n\n\nset.seed(0)\n### erstes Modell: Cluster mit zum Koordinatensystem parallelen Achsen, gleicher Groesse:\nm1 <- Mclust(data=geyser, G=3, modelNames = rep(\"EII\", 3))\nsummary(m1, parameters=TRUE)                                 ## BIC = -3770.529\n\n\nplot(m1, what=\"classification\")        ## Daten mit berechneter Clusterung und Normalverteilungsellipse (Achsenl?nge = Standardabweichung)\nplot(m1, what=\"uncertainty\")           ## Unsicherheit: je dicker der Punkt, desto unsicherer ist die Zuteilung der Beobachtung zu einem Cluster\nplot(m1, what=\"density\")               ## Konturlinien der Mischverteilung    (vogelwild...)\n\n## Zwischenfazit: die parallelen und gleich grossen Cluster sind hier ungeeignet\n\n\n### zweites Modell: parallele Cluster mit unterschiedlicher Groesse und Form:\nm2 <- Mclust(data=geyser, G=3, modelNames = rep(\"VVI\", 3))\nsummary(m2, parameters=TRUE)                                 ## BIC = -2813.52\n\nplot(m2, what=\"classification\")       \nplot(m2, what=\"uncertainty\")           \nplot(m2, what=\"density\")                                     ## viel besser im Vergleich zu m1\n\n\n### drittes Modell: nicht-parallele Cluster mit unterschiedlicher Groesse und Form:    (maximale Flexibilit?t)\nm3 <- Mclust(data=geyser, G=3, modelNames = rep(\"VVV\", 3))\nsummary(m3, parameters=TRUE)                                 ## BIC = -3059.029\n\nplot(m3, what=\"classification\")                              ## passt nicht\nplot(m3, what=\"uncertainty\")           \nplot(m3, what=\"density\")                                     ## passt nicht\n\n\n\n#### m2 liefert mit Abstand das beste BIC (aller moeglicher Spezifikationen, auch der nicht Gezeigten).\n#### Optisch scheint m2 ebenfalls sinnvoll zu clustern.\n\n## geschaetzte posteriori-Wkt. aller Beobachtungen:\nround(m2$z, 3)\n## zu Diagnosezwecken betrachtet man haeufig folgendes Histogram, bei dem sich bei \n## gut separierten Mischkomponenten moeglichst alle Werte nahe 0 oder nahe 1 befinden sollten:\nhist(round(m2$z, 3))\n\n## Klassifikation:\nm2$classification\n## Unsicherheit bezueglich der Zuteilung:\nround(m2$uncertainty, 3)\ntable(round(m2$uncertainty, 3))\n\nqf(0.95, df1 = 2,df2 = 33)\n\n#ÜB 10\ndata=read.table(\"europa.txt\",header = T)\ndata=data[,-1]\ndata\nmittel=c(mean(data[,1]),mean(data[,2]),mean(data[,3]),mean(data[,4]))\nvar=cov(data)\ndata=(data-mittel)/(var)\ndata=scale(data)\ndata=data[,]\ndata\nvar=cov(data)\nvar\neV=c(eigen(var)$values[1]/(sum(eigen(var)$values)),\neigen(var)$values[2]/(sum(eigen(var)$values)),\neigen(var)$values[3]/(sum(eigen(var)$values)),\neigen(var)$values[4]/(sum(eigen(var)$values)))\neigen(var)$vectors\nas.numeric(data[22,])%*%eigen(var)$vectors\nas.numeric(data[7,])%*%eigen(var)$vectors\n\n\na=prcomp(cor(data))\nsummary(a)\neigen(cor(data))\n\na$sdev^2\na$sdev^2-eigen(cor(data))$values\neigen(cor(data))\nprincomp(var(data))\n\ndata=scale(data)\n\neigen(var(data))\n\nvar(data)\ns#Screeplot\nscreeplot(x = princomp(data,cor = T),type = \"lines\")\nplot(c(1,2,3,4),eV,type = \"l\")\nsummary(princomp(data,cor = T,scores = T,))\ncor(data)\n",
    "created" : 1467020107171.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1820240737",
    "id" : "A29CB087",
    "lastKnownWriteTime" : 4532309248,
    "last_content_update" : 1467821841562,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}